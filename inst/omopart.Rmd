---
title: "experimental OMOP visualisations"
output:
  html_document:
    keep_md: yes
author: "Andy South"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
---

A progression of experimental OMOP visualisations. The intention is not that this document should be knitted, but that it provides a record of ongoing visualisation attempts by the package author. Most of these are from omop_graph() calls each of which generates a plot saved as pdf.   

```{r setup, include=FALSE}

library(here)
library(knitr)
library(tidyverse)
library(dplyr)
#library(dbplyr)
library(igraph)
library(tidygraph)
library(ggraph)
#library(odbc)
#library(glue)

knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE,
                      dev = "png",
                      dpi = 300,
                      cache = TRUE)
```


```{r install github packages, include=FALSE, eval=TRUE}

# library(remotes) #for install_github
# remotes::install_github("andysouth/omopcept")
library(omopcept)

```

#### new stuff 2023-10-16 using omop_graph()

```{r omop_graph() calls, include=FALSE, eval=TRUE}

cancer <- omop_names("cancer")
#returning 3340 concepts

neor2 <- omop_relations_recursive("Malignant neoplasms",num_recurse = 2,r="Subsumes")

#this is pretty good
omop_graph(neor2, plot=FALSE, filenameroot = "neoplasm_subsumes2",width=80, height=110)

#what is this error about ? I think I've had before.
# Error in grid.Call(C_convert, x, as.integer(whatfrom), as.integer(whatto), :
# Viewport has zero dimension(s)

#that is all ICD10, if I include 'maps to' or similar relations 
# first check what relations there are
neor1 <- omop_relations_recursive("Malignant neoplasms",num_recurse = 1) #,r="Subsumes")
#they are only is a or subsumes
neor2all <- omop_relations_recursive("Malignant neoplasms",num_recurse = 2)

omop_graph(neor2all, plot=FALSE, filenameroot = "neoplasm2",width=80, height=110)

omop_graph(neor2all, plot=FALSE, filenameroot = "neoplasm2",width=80, height=110, node_colour_var = "vocabulary_id")

#2024-06-17 trying vis for OHDSI global 2024
neop_snomed <- omop_names("Malignant neoplasm",s="S",v="SNOMED",exact=TRUE)

neop_snomed_r1  <- omop_relations_recursive(neop_snomed$concept_id, num_recurse = 1)

neop_snomed_r1 |> count(relationship_id, sort=TRUE)
#  1 Asso morph of         1436
#  2 Has inherent           404
#  3 Component of           129
#  4 Subsumes               122
#  5 Relative to of          83
#  6 Dir morph of            18
#  7 Mapped from              6
#  8 Concept poss_eq from     2
#  9 Concept replaces         1
# 10 Has Module               1
# 11 Has status               1
# 12 Is a                     1
# 13 Proc morph of            1

#test colouring by other var
omop_graph(neop_snomed_r1, nodecolourvar="relationship_id")
#TODO sort problem here 
# Error in `ggraph::geom_node_point()` at omopcept/R/omop_graph.R:152:2:
# ! Problem while computing aesthetics.
# ℹ Error occurred in the 2nd layer.
# Caused by error in `.data[["relationship_id"]]`:
# ! Column `relationship_id` not found in `.data`.


#TODO maybe try some vis with mapped from, to. OHDSI people interested in that

neop_snomed_r2  <- omop_relations_recursive(neop_snomed$concept_id, num_recurse = 2)

music <- omop_names("music")
#returning 120 concepts

instrument <- omop_names("instrument")
#returning 628 concepts

#If music be the food of omop !
#music_rel <- omop_relations_multiple(music$concept_id, r_ids=c('Is a'))

#write_csv(music_rel, file=here("inst/extdata/music-relations.csv"))

#because above takes > 5 mins, saved as csv
music_rel <- read_csv("inst/extdata/music-relations.csv")

omop_graph(music_rel, plot=FALSE, filenameroot = "music",width=80, height=110)

omop_graph(music_rel, plot=FALSE, filenameroot = "music-titled",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "If music be the food of ... OMOP ...",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#but the music plot didn't look great

# trying a blood plot
bloodgroup <- omop_names("blood group")

bloodgroup |> count(concept_class_id,sort=TRUE)

bloodgroupcomponent <- bloodgroup |> filter(concept_class_id=="LOINC component")

bloodgrouprels <- omop_relations_multiple(bloodgroupcomponent$concept_id)

omop_graph(bloodgrouprels, plot=FALSE, filenameroot = "bloodgroup",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "There will be blood ... in OMOP ...",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#try instead to subset relations table by just those starting with R
#should be quick
rrelations2 <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("^r",concept_name_1, ignore.case=TRUE)) |> 
  collect()

#too big

#freq_rid_rrelations
#    relationship_id           n
#  1 Mapped from          102954
#  2 Maps to              102490
#  3 Brand name of         69857
#  4 Is a                  62037
#  5 Subsumes              61770
#  6 Has marketed form     60968
#  7 Marketed form of      47477
#  8 RxNorm has dose form  41287
#  9 Has brand name        40397
# 10 Has Module            40063

rrel_is_sub <- rrelations2 |> 
  filter(relationship_id %in% c("Is a","Subsumes")) 

#123k rows - maybe too much

# this takes ages
#omop_graph(rrel_is_sub, plot=FALSE, filenameroot = "rrelations",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "OMOP ART #1 : R relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

rrelicd10 <- rrel_is_sub |> 
  filter(vocabulary_id == "ICD10") |> 
  filter(str_detect(concept_name_1,"injured"))

# how else could I filter ??
# perhaps length of concept_name1 - lots of drugs with very long names ??
rrel_is_sub2 <- rrel_is_sub |> 
  filter(concept_name_2 != "Actual medicinal product pack") |> 
  filter(concept_name_1 != "Actual medicinal product pack") |> 
  filter(concept_name_2 != "Actual medicinal product") |> 
  filter(concept_name_1 != "Actual medicinal product") |> 
  filter(concept_class_id != "Pharma/Biol Product") |> 
  filter(vocabulary_id != "OMOP Genomic")

rrel_is_sub2 |> count(concept_class_id,sort=TRUE)
# # A tibble: 69 × 2
#    concept_class_id         n
#    <chr>                <int>
#  1 Procedure            29374
#  2 Pharma/Biol Product  13944
#  3 Clinical Finding     13398
#  4 LOINC Class          11589
#  5 LOINC Group           9317
#  6 Clinical Observation  4738
#  7 Physical Object       4728
#  8 LOINC Hierarchy       3763
#  9 Lab Test              3752
# 10 LOINC Component       2630

rrel_is_sub2 |> count(vocabulary_id,sort=TRUE)
rrel_is_sub3 |> count(domain_id,sort=TRUE)

#because its taking for ever maybe sort by concept_name_1
#and start trying to just slice_head()
#start with a smallish one, maybe 10k & see how it does
#seems that 2.5 - 3k is max can get in this plot

rrel_is_sub3 <- rrel_is_sub2 |> 
  #try other way to just select ICD10 & snomed
  filter(vocabulary_id %in% c("ICD10","SNOMED")) |>
  filter(concept_class_id != "LOINC Class") |>
  filter(!domain_id %in% c("Drug","Type Concept","Race","Provider","Unit","Metadata","Meas Value")) |>  
  filter(!grepl("^r ",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^r ",concept_name_2, ignore.case=TRUE)) |>  
  filter(!grepl("^r'",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^r'",concept_name_2, ignore.case=TRUE)) |>
  filter(!grepl("^rf",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^rf",concept_name_2, ignore.case=TRUE)) |>  
  filter(!grepl("^rb",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^rb",concept_name_2, ignore.case=TRUE)) |>
  filter(!grepl("^radiology",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^radiology",concept_name_2, ignore.case=TRUE)) |>  
  arrange(concept_name_1) |> 
  slice_head(n= 2000)

#add on nice injuries
rrel_is_sub3 <- bind_rows(rrel_is_sub3,rrelicd10)

# FINAL PLOT FOR OHDSI GLOBAL POSTER
omop_graph(rrel_is_sub3, plot=FALSE, filenameroot = "rrelations",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "OMOP ART #1 : R relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

# try some cancer plots
cancer_rel <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("cancer",concept_name_1, ignore.case=TRUE)) |> 
  collect()

#26k rows in relation table with cancer in concept1

freq_cancer_rel_domain <- cancer_rel |> count(domain_id, sort=TRUE)
freq_cancer_rel_vocab <- cancer_rel |> count(vocabulary_id, sort=TRUE)

#    vocabulary_id          n
#  1 LOINC              13724
#  2 SNOMED              5883
#  3 HemOnc              3394
#  4 RxNorm Extension    1703
#  5 UK Biobank           799
#  6 Cancer Modifier      394
#  7 HCPCS                359
#  8 Read                 185
#  9 OncoTree             101
# 10 OMOP Genomic          68

cancer_rel_hemonc <- cancer_rel |> filter(vocabulary_id=="HemOnc")

omop_graph(cancer_rel_hemonc, plot=FALSE, filenameroot = "cancer_hemonc",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cancer relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#what happens if just subset HemOnc

hemonc_rel <- omop_concept_relationship() |> 
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(vocabulary_id=="HemOnc") |> 
  collect()

#70k rows

freq_hemonc_rel_domain <- hemonc_rel |> count(domain_id, sort=TRUE)
freq_hemonc_rel_rship <- hemonc_rel |> count(relationship_id, sort=TRUE)

#  1 Accepted use of       5092
#  2 Has accepted use      5092
#  3 Subsumes              4373
#  4 Brand name of         4207
#  5 Has brand name        4207
#  6 Cytotoxic chemo of    3891
#  7 Has cytotoxic chemo   3891
#  8 Has cytotox chemo Rx  3876
#  9 Is a                  3222
# 10 Context of            2872

hemonc_rel_chemo <- hemonc_rel |> filter(relationship_id=="Cytotoxic chemo of")
#3.8k rows

omop_graph(hemonc_rel_chemo, plot=FALSE, filenameroot = "chemo_hemonc",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cytotoxic chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#I expected the above to have links from cancers to treatments - but it didn't

hemonc_rel_has_chemo <- hemonc_rel |> filter(relationship_id=="Has cytotoxic chemo")
#3.8k rows

omop_graph(hemonc_rel_has_chemo, plot=FALSE, filenameroot = "chemo_has_hemonc",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cytotoxic chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


hemonc_rel_accepted_chemo <- hemonc_rel |> filter(relationship_id=="Accepted use of")
#3.8k rows

omop_graph(hemonc_rel_accepted_chemo, plot=FALSE, filenameroot = "chemo_hemonc_accepted",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cytotoxic chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

# try filtering lung cancer

hemonc_rel_lung <- hemonc_rel |> 
  filter(grepl("lung",concept_name_1, ignore.case=TRUE)) 

# only has conditions

omop_graph(hemonc_rel_lung, plot=FALSE, filenameroot = "chemo_hemonc_lung",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Lung chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


cancer_lung_rel <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("cancer",concept_name_1, ignore.case=TRUE)) |> 
  filter(grepl("lung",concept_name_1, ignore.case=TRUE)) |> 
  collect()

# only has conditions

omop_graph(cancer_lung_rel, plot=FALSE, filenameroot = "cancer_lung",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Lung cancer relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


# pregnancy

preg_rel <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("pregnan",concept_name_1, ignore.case=TRUE)) |> 
  #filter(grepl("lung",concept_name_1, ignore.case=TRUE)) |> 
  collect()

#30k pregnancy relationships

freq_preg_rel_domain <- preg_rel |> count(domain_id, sort=TRUE)
freq_preg_rel_rship <- preg_rel |> count(relationship_id, sort=TRUE)
#  1 Mapped from         4370
#  2 Maps to             3814
#  3 Is a                3438
#  4 Has Module          2654
#  5 Has status          2650
#  6 Subsumes            2460
#  7 Interprets of       1305
#  8 Has finding site     724
#  9 Has interprets       717
# 10 Concept was_a from   566

preg_rel_isa <- preg_rel |> filter(relationship_id=="Is a") 
#3.4k

#try filtering those that have preg in concept 1 & 2
preg_rel_preg <- preg_rel |> 
    filter(grepl("pregnan",concept_name_2, ignore.case=TRUE)) 
#15k

omop_graph(preg_rel_isa, plot=FALSE, filenameroot = "preg_isa",width=100, height=60, units="in", node_txtsize = 14, graphtitle = "Pregnancy 'Is a' relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

pregnames <- omop_names("pregnan")
#4381 rows

birthdatenames <- omop_names("birth date")
#returning 10 concepts
birthnames <- omop_names("birth")
#returning 2116 concepts
cesariannames <- omop_names("cesarian")
#returning 4 concepts & are invalid_reason = D

#some docs, move these later

#1. decide which domain (generally using Observation as final)
#(note condition table doesn't allow you to modify things )

#2. search for concept_id

# For births you can use fact relationship table to link mother & child

# [] in Athena, square brackets indicate a standard survey

# when setting up a consortium project important that mapping conventions
# are agreed early on, otherwise one site may make decisions that impact 
# heavily on the way 

clb <- omop_names("certificate of live birth")
#26

cert_live_birth_rel <- omop_relations_recursive(1012231, num_recurse = 1)

omop_graph(cert_live_birth_rel, plot=FALSE, filenameroot = "cert_live_birth",width=30, height=20, units="in", node_txtsize = 18, graphtitle = "Certificate of live birth",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


#omopmas 2023

chr <- omop_names('christmas')
rei <- omop_names('reindeer')
mis <- omop_names('mistletoe')

chr_rel <- omop_relations_multiple(chr$concept_id)
rei_rel <- omop_relations_multiple(rei$concept_id)
mis_rel <- omop_relations_multiple(mis$concept_id)

omop_graph(chr_rel)
omop_graph(rei_rel)

chr_rei_rel <- bind_rows(chr_rel,rei_rel)

#A4 title text over-runs
omop_graph(chr_rel, filenameroot = "omopmas", graphtitle = "Happy OMOPmas !",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept",width=210, height=297, units="mm", node_txtsize = 24)
#A3
omop_graph(chr_rel, filenameroot = "omopmas", graphtitle = "Happy OMOPmas !",graphsubtitle = "made by @southmapr 2023 using OMOP, R & https://github.com/andysouth/omopcept",width=297, height=420, units="mm", node_txtsize = 24)


```


#### OLD below here, some useful code generating inputs 

```{r extract data, include=FALSE, eval=TRUE}

dfsnomed <- omop_descendants(v_ids="SNOMED",separation=1)
#returning 910497 concepts
dfsnomed |>  count(domain_id,sort=TRUE)
#  1 Device              382492
#  2 Condition           218064
#  3 Observation         125732
#  4 Procedure           100106
#  5 Spec Anatomic Site   54239
#  6 Measurement          24028
#  7 Specimen              3061
#  8 Meas Value            1403
#  9 Language               888
# 10 Relationship           282
# 11 Route                  192
# 12 Meas Value Operator      5
# 13 Spec Disease Status      5

#7.2 million concepts
dfsnomedall <- omop_descendants(v_ids="SNOMED")
#1 million concepts
dfloinc <- omop_descendants(v_ids="LOINC")

dfcancermod <- omop_descendants(v_ids="Cancer Modifier",separation=1)
#returning 6759 concepts
dfcancermod |>  count(domain_id,sort=TRUE)
#just one domain
#1 Measurement  6759

#to get a smaller test dataset
dffigo <- dfcancermod |> filter(str_detect(concept_name,"FIGO"))

names_lymph <- omop_names("lymphoma",v="SNOMED")

#returning 17 concepts
names_dlbcl <- omop_names("Diffuse large B-cell lymphoma",v="SNOMED")
#Diffuse large B-cell lymphoma : 44808122
dfme <- omop_descendants(c_id=44808122, v_ids="SNOMED")
#!! wow 7 million concepts descending from DLBCL returning 7277526 concepts
freq_domain_id <- dfme |>  count(domain_id,sort=TRUE)
#  1 Condition           2424403
#  2 Spec Anatomic Site  1372365
#  3 Device              1233671
#  4 Procedure           1118391
#  5 Observation          941751
#  6 Measurement          164036
#  7 Specimen              13910
#  8 Meas Value             3725
#  9 Language               3321
# 10 Relationship           1369
# 11 Route                   555
# 12 Meas Value Operator      15
# 13 Spec Disease Status      14

# they are all standard
# freq_standard_concept <- dfme |>  count(standard_concept,sort=TRUE)

freqsep <- dfme |>  count(min_levels_of_separation,sort=FALSE)
#I could limit level of separation
#still 5.6 million !
dfme5 <- omop_descendants(c_id=44808122, v_ids="SNOMED",separation=c(1:5))
#4.6 million
dfme4 <- dfme5 |> filter(min_levels_of_separation<=4) 
#3.3 million
dfme3 <- dfme5 |> filter(min_levels_of_separation<=3)
#2 million
dfme2 <- dfme5 |> filter(min_levels_of_separation<=2)
#0.9 million
dfme1 <- dfme5 |> filter(min_levels_of_separation<=1)

freq_domain_id <- dfme5 |>  count(domain_id,sort=TRUE)

#filter all snomed for just those that contain blood
#but note that dfsnomed was just separation=1
dfsnoblood <- dfsnomed |>  filter(grepl("blood", concept_name, ignore.case=TRUE)) 
#dfsnomedall has all separations
dfsnobloodgroup <- dfsnomedall |>  
  #filter(min_levels_of_separation<=3) |> 
  filter(grepl("blood group", concept_name, ignore.case=TRUE)) 

#96k
dfloincblood <- dfloinc |>  filter(grepl("blood", concept_name, ignore.case=TRUE)) 

#300
dfloincbloodgroup <- dfloinc |>  
  #filter(min_levels_of_separation<=3) |> 
  filter(grepl("blood group", concept_name, ignore.case=TRUE)) 

#news2 scores
#can get the snomed codes from omopcept, 10 rows, one seems to be ancestor
dfnews2 <- omop_names("news2", v_ids="SNOMED", d_ids="measurement" )
#WHY does this return 7 million concepts, suggests a BUG
#is this just all decsendants with a separation of 1 ??
dfnews2ds1 <- omop_descendants(37208354, separation=1)
dfnews2ds2 <- omop_descendants(37208354, separation=c(1,2))



#for oxford meeting

#139 concepts
dfoxford <-  omop_names("oxford") 

#try single descendants of oxford
#could do via concept relationship

#could go through all 139 concepts in a loop
#TODO generalise this into a function
#omop_ancestors_multi()
#or maybe even put it into omop_ancestors
dfoxdes <- dfoxanc <- NULL
for(i in 1:nrow(dfoxford))
{
  dfdtmp <- omop_descendants(dfoxford$concept_id[i]) #, separation=1) 
  dfatmp <- omop_ancestors(dfoxford$concept_id[i]) #, separation=1) 
    
  #if(i==1) dfoxdes <- dftmp
  dfoxdes <- bind_rows(dfoxdes, dfdtmp)
  dfoxanc <- bind_rows(dfoxanc, dfatmp)
}

dfox <- bind_rows(dfoxanc, dfoxdes)

dfox2 <- dfox |> filter(min_levels_of_separation <= 2)
dfox1 <- dfox |> filter(min_levels_of_separation <= 1)

#98
dfoxa1 <- dfoxanc |> filter(min_levels_of_separation <= 1)


#for NHS-R talk
vehicle_accident_descendants <- omop_descendants(4168046)

#for Steve
critical1 <- omop_concept_relationship() |> omop_join_name_all(domain=TRUE,vocabulary=TRUE) |> filter(grepl("ritical care",concept_name_1)) |>  collect()

#holidays for away day
holidays <- omop_names("holiday")
holsanc <- NULL
holsrel <- NULL
for(i in 1:nrow(holidays))
{
  #dfdtmp <- omop_descendants(dfoxford$concept_id[i]) #, separation=1) 
  #dfatmp <- omop_ancestors(holidays$concept_id[i],itself=TRUE)
  dfatmp <- omop_relations(holidays$concept_id[i])
    
  #if(i==1) dfoxdes <- dftmp
  #dfoxdes <- bind_rows(dfoxdes, dfdtmp)
  #holsanc <- bind_rows(holsanc, dfatmp)
  holsrel <-  bind_rows(holsrel, dfatmp)
}

# cancer staging

#1 concept
ajccfinding <- omop_names("AJCC/UICC finding", fixed=TRUE)

ajcc_rel1 <- omop_relations_recursive(734320, num_recurse=1)
ajcc_rel2 <- omop_relations_recursive(734320, num_recurse=2)
#does it make it quicker if I filter by vocab ? not hugely it seems
ajcc_rel2quick <- omop_relations_recursive(734320, num_recurse=2, v_ids = "Cancer Modifier")

#good first tree plot (although lots of nodes don't get labelled)
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE)
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width=200)

#dendrogram & treemap give :
#! `graph` doesn't contain a root.ℹ  Provide graph with one parentless node
# adding one row to the data can fix (see below)
# could even do it in omop_graph()
# but dendrogram & treemap initial results were a bit rubbish anyway 

ar2 <- ajcc_rel2
ar2[1+nrow(ar2),]$concept_name_2 <- ar2[1,]$concept_name_1
omop_graph(ar2, ggrlayout="dendrogram", legendshow = FALSE) #looks same as tree

#try taking out the edition nodes
ajcc_rel2_no_ed <- ajcc_rel2 |> 
  filter(!str_detect(concept_name_1, "edition"))

omop_graph(ajcc_rel2_no_ed, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 100)

# GOOD nodetxtangle = 45 makes most labels visible
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 150, nodetxtangle = 45)

omop_graph(ajcc_rel2, legendshow = FALSE, saveplot = TRUE, width = 100, height=100)

# trying a smaller plot for the vignette 2024-06

ajcc8 <- omop_names("AJCC/UICC 8th edition", exact=TRUE)

ajcc_rel1 <- omop_relations_recursive(ajcc8$concept_id, num_recurse=1)

# getting recursive relations takes a few minutes
ajcc_rel2 <- omop_relations_recursive(ajcc8$concept_id, num_recurse=2)

# plot is too big to display nicely in this vignette
# but is auto saved in a nice to pdf
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 150, nodetxtangle = 45)


# figo
# interesting that figo hierarchy seems different, i.e. edition is child of stages

figofind <- omop_names("figo finding")

figofind[1,]$concept_id 

figo_rel1 <- omop_relations_recursive(734316, num_recurse=1)
figo_rel2 <- omop_relations_recursive(734316, num_recurse=2)

omop_graph(figo_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 50, nodetxtangle = 45)

# try to make a pretty cancer plot for Steve's talk
# perhaps start at something detailed and work up ?
cm <- omop_names("", v_ids="Cancer Modifier")
#returning 6043 concepts
cm |> count(concept_class_id, sort=TRUE)
#  1 Staging/Grading     3281
#  2 Metastasis           579
#  3 Extension/Invasion   545
#  4 Topography           518
#  5 Histopattern         444
#  6 Margin               433
#  7 Nodes                192
#  8 Dimension             29
#  9 Morph Abnormality     15
# 10 Qualifier Value        7

bc <- omop_names("breast cancer") #244
bcs <- omop_names("breast cancer",v="SNOMED") #49

labc <- omop_names("Locally advanced breast cancer")
labcr1 <- omop_relations_recursive(labc$concept_id[1],num_recurse = 1)


mm <- omop_names("multiple myeloma")
#returning 53 concepts
mms <- omop_names("multiple myeloma",exact=TRUE,d="Condition",v="SNOMED",s="S")
#1
mmsr1 <- omop_relations(mms$concept_id)
#returning 50 concepts
mmsr1 |> count(relationship_id, sort=TRUE)
#  1 Mapped from             18
#  2 Subsumes                11
#  3 Due to of                7
#  4 Concept same_as from     3
#  5 Asso finding of          2
#  6 Focus of                 2
#  7 Asso with finding        1
#  8 Concept replaces         1
#  9 Has Module               1
# 10 Has asso morph           1
# 11 Has status               1
# 12 Is a                     1
# 13 Value mapped from        1
#This is nice, MMyeloma at centre, 6 different domains
omop_graph(mmsr1)


#with newly added names2avoid defaults that avoid e.g. Primitive
mmsr2 <- omop_relations_recursive(mms$concept_id, num_recurse=2)

omop_graph(mmsr2)

#2024-06-02 ohdsi concepts workshop
#Snomed does not think that Arthropathic psoriasis is a psoriasis !
#ICD10 does

#get one parent concept
pso <- omop_names("Psoriasis",exact=TRUE,s="S",v="SNOMED")
psorel2

ra <- omop_names("rheumatoid arthritis",exact=TRUE,s="S",v="SNOMED")

ra_rel1 <- omop_relations_recursive(ra$concept_id, num_recurse=1)
ra_rel2 <- omop_relations_recursive(ra$concept_id, num_recurse=2)

ra_rel1mapped <- ra_rel1 %>% filter(relationship_id=="Mapped from")
ra_rel2mapped <- ra_rel2 %>% filter(relationship_id=="Mapped from")

#look at hierarchy of ICD10 codes for RA

m06 <- omop_codes("M06.0")
m06_rel <- omop_relations_recursive(m06$concept_id)
omop_graph(m06_rel)
m06_rel2 <- omop_relations_recursive(m06$concept_id, num_recurse = 2)

omop_graph(m06_rel2, ggrlayout = "tree")

#to do regex &, need to search both one after other & other way around
amox_clav <- omop_names("amoxicillin.*clavulanate|clavulanate.*amoxicillin")

amox_clav <- omop_names("amoxicillin.*clavulanate|clavulanate.*amoxicillin",v=c("RxNorm","RxNorm Extension"))

amox_clav %>% count(concept_class_id, sort=TRUE)

multing <- amox_clav %>% filter(concept_class_id=="Multiple Ingredients")

# 2024-07-03
# looking at relationship_ids with John
# every relationship_id has an equivalent going in other direction
# and they have identical num rows, 
# so sorting on the count puts them next to each other
freq_r <- omop_concept_relationship() |> count(relationship_id, sort=TRUE) |>  collect()


# 2024-07-05
# new approach finding a generic concept & just searching down (Subsumes)
# allows a representative tree map to be produced

neor2 <- omop_relations_recursive("Malignant neoplasms",num_recurse = 2,r="Subsumes")

omop_graph()



#this is pretty good
omop_graph(neor2, plot=FALSE, filenameroot = "neoplasm_subsumes2",width=80, height=110)



```

```{r first test plot, include=FALSE, eval=TRUE}

# If you want to go beyond ~20k nodes, then you may want to switch to layout_with_pmds() or layout_with_sparse_stress() which are optimized to work with large graphs.


#selecting data to plot
#challenge to get down to a small enough number
dfin <- dffigo
dfin <- dfme3
dfin <- dfme3 |> head(2000)

dfin <- dfme1

#MAYBE SAVE ONE OF OMOP DATA OBJECTS IN PACKAGE TO SPEED PLOT PRODUCTION

#try filtering an equal number of domains
dfin <- dfme3 |> 
#post submission perhaps I want to start from just direct connections, separation1
#but the plot didn't look as good! not sure which is best
#dfin <- dfme1 |>   
  filter(domain_id %in% freq_domain_id$domain_id[1:7]) |> 
  group_by(domain_id) |> 
  #top x rows for each group
  slice_head(n=500) |> 
  ungroup()


# dfin <- dfsnoblood
# dfin <- dfsnobloodgroup
# dfin <- dfloincblood
# dfin <- dfloincbloodgroup

dfin <- dfnews2d
dfin <- dfoxa1
dfin <- vehicle_accident_descendants
dfin <- critical1
dfin <- holsanc
dfin <- holsrel


if ("ancestor_name" %in% names(dfin)){
  
  #DESCENDANT
  dfin2 <- dfin |> 
    dplyr::rename(from = ancestor_name,
                  to = concept_name)    
  
} else if ("descendant_concept_name" %in% names(dfin)){
  
  #ANCESTOR
  dfin2 <- dfin |>
   dplyr::rename(from = descendant_concept_name,
                 to = concept_name)
  
} else if ("concept_name_1" %in% names(dfin)){
  
  #RELATION
  dfin2 <- dfin |>
   dplyr::rename(from = concept_name_1,
                 to = concept_name_2)
  
}


  
#saving plots
#naming convention
#s  separation min
#m  plot metres
#ea edge alpha
#ta text alpha  
#pdark2 palette color brewer
#ns node sized
#nts node text size
#d? domains
  
ggsave(ggr,filename="holidaysrel-pset1-05m-ns.pdf",width=50,height=30,units="cm",limitsize = FALSE)

ggsave(ggr,filename="critical1-pset1-05m-ns.pdf",width=50,height=50,units="cm",limitsize = FALSE)
    
ggsave(ggr,filename="accident-vehicle-pset1-05m-ns.pdf",width=50,height=50,units="cm",limitsize = FALSE)
    
ggsave(ggr,filename="oxa-s1-pset1-06x03m-ns-nts7.pdf",width=60,height=30,units="cm",limitsize = FALSE)
  
ggsave(ggr,filename="ox-s2-pset1-05m-ns.pdf",width=50,height=50,units="cm",limitsize = FALSE)
   
ggsave(ggr,filename="dlbcl-s1-pset1-15m-ns.pdf",width=150,height=150,units="cm",limitsize = FALSE)    
   
ggsave(ggr,filename="dlbcl-s3-d7-500-pset1-15m-ns.pdf",width=150,height=150,units="cm",limitsize = FALSE)  


```

