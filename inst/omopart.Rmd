---
title: "experimental OMOP visualisations"
output:
  html_document:
    keep_md: yes
author: "Andy South"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
---

A progression of experimental OMOP visualisations. The intention is not that this document should be knitted, but that it provides a record of ongoing visualisation attempts by the package author. Most of these are from omop_graph() calls each of which generates a plot saved as pdf.   

```{r setup, include=FALSE}

library(here)
library(knitr)
library(tidyverse)
library(dplyr)
#library(dbplyr)
library(igraph)
library(tidygraph)
library(ggraph)
#library(odbc)
#library(glue)

knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE,
                      dev = "png",
                      dpi = 300,
                      cache = TRUE)
```


```{r install github packages, include=FALSE, eval=TRUE}

# library(remotes) #for install_github
# remotes::install_github("andysouth/omopcept")
library(omopcept)

```

#### new stuff 2023-10-16 using omop_graph()

```{r omop_graph() calls, include=FALSE, eval=TRUE}

cancer <- omop_names("cancer")
#returning 3340 concepts

neor2 <- omop_relations_recursive("Malignant neoplasms",num_recurse = 2,r="Subsumes")

#this is pretty good
omop_graph(neor2, plot=FALSE, filenameroot = "neoplasm_subsumes2",width=80, height=110)

#what is this error about ? I think I've had before.
# Error in grid.Call(C_convert, x, as.integer(whatfrom), as.integer(whatto), :
# Viewport has zero dimension(s)

#that is all ICD10, if I include 'maps to' or similar relations 
# first check what relations there are
neor1 <- omop_relations_recursive("Malignant neoplasms",num_recurse = 1) #,r="Subsumes")
#they are only is a or subsumes
neor2all <- omop_relations_recursive("Malignant neoplasms",num_recurse = 2)

omop_graph(neor2all, plot=FALSE, filenameroot = "neoplasm2",width=80, height=110)

omop_graph(neor2all, plot=FALSE, filenameroot = "neoplasm2",width=80, height=110, node_colour_var = "vocabulary_id")

#2024-06-17 trying vis for OHDSI global 2024
neop_snomed <- omop_names("Malignant neoplasm",s="S",v="SNOMED",exact=TRUE)

neop_snomed_r1  <- omop_relations_recursive(neop_snomed$concept_id, num_recurse = 1)

neop_snomed_r1 |> count(relationship_id, sort=TRUE)
#  1 Asso morph of         1436
#  2 Has inherent           404
#  3 Component of           129
#  4 Subsumes               122
#  5 Relative to of          83
#  6 Dir morph of            18
#  7 Mapped from              6
#  8 Concept poss_eq from     2
#  9 Concept replaces         1
# 10 Has Module               1
# 11 Has status               1
# 12 Is a                     1
# 13 Proc morph of            1

#test colouring by other var
omop_graph(neop_snomed_r1, nodecolourvar="relationship_id")
#TODO sort problem here 
# Error in `ggraph::geom_node_point()` at omopcept/R/omop_graph.R:152:2:
# ! Problem while computing aesthetics.
# ℹ Error occurred in the 2nd layer.
# Caused by error in `.data[["relationship_id"]]`:
# ! Column `relationship_id` not found in `.data`.


#TODO maybe try some vis with mapped from, to. OHDSI people interested in that

neop_snomed_r2  <- omop_relations_recursive(neop_snomed$concept_id, num_recurse = 2)

music <- omop_names("music")
#returning 120 concepts

instrument <- omop_names("instrument")
#returning 628 concepts

#If music be the food of omop !
#music_rel <- omop_relations_multiple(music$concept_id, r_ids=c('Is a'))

#write_csv(music_rel, file=here("inst/extdata/music-relations.csv"))

#because above takes > 5 mins, saved as csv
music_rel <- read_csv("inst/extdata/music-relations.csv")

omop_graph(music_rel, plot=FALSE, filenameroot = "music",width=80, height=110)

omop_graph(music_rel, plot=FALSE, filenameroot = "music-titled",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "If music be the food of ... OMOP ...",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#but the music plot didn't look great

# trying a blood plot
bloodgroup <- omop_names("blood group")

bloodgroup |> count(concept_class_id,sort=TRUE)

bloodgroupcomponent <- bloodgroup |> filter(concept_class_id=="LOINC component")

bloodgrouprels <- omop_relations_multiple(bloodgroupcomponent$concept_id)

omop_graph(bloodgrouprels, plot=FALSE, filenameroot = "bloodgroup",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "There will be blood ... in OMOP ...",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#try instead to subset relations table by just those starting with R
#should be quick
rrelations2 <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("^r",concept_name_1, ignore.case=TRUE)) |> 
  collect()

#too big

#freq_rid_rrelations
#    relationship_id           n
#  1 Mapped from          102954
#  2 Maps to              102490
#  3 Brand name of         69857
#  4 Is a                  62037
#  5 Subsumes              61770
#  6 Has marketed form     60968
#  7 Marketed form of      47477
#  8 RxNorm has dose form  41287
#  9 Has brand name        40397
# 10 Has Module            40063

rrel_is_sub <- rrelations2 |> 
  filter(relationship_id %in% c("Is a","Subsumes")) 

#123k rows - maybe too much

# this takes ages
#omop_graph(rrel_is_sub, plot=FALSE, filenameroot = "rrelations",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "OMOP ART #1 : R relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

rrelicd10 <- rrel_is_sub |> 
  filter(vocabulary_id == "ICD10") |> 
  filter(str_detect(concept_name_1,"injured"))

# how else could I filter ??
# perhaps length of concept_name1 - lots of drugs with very long names ??
rrel_is_sub2 <- rrel_is_sub |> 
  filter(concept_name_2 != "Actual medicinal product pack") |> 
  filter(concept_name_1 != "Actual medicinal product pack") |> 
  filter(concept_name_2 != "Actual medicinal product") |> 
  filter(concept_name_1 != "Actual medicinal product") |> 
  filter(concept_class_id != "Pharma/Biol Product") |> 
  filter(vocabulary_id != "OMOP Genomic")

rrel_is_sub2 |> count(concept_class_id,sort=TRUE)
# # A tibble: 69 × 2
#    concept_class_id         n
#    <chr>                <int>
#  1 Procedure            29374
#  2 Pharma/Biol Product  13944
#  3 Clinical Finding     13398
#  4 LOINC Class          11589
#  5 LOINC Group           9317
#  6 Clinical Observation  4738
#  7 Physical Object       4728
#  8 LOINC Hierarchy       3763
#  9 Lab Test              3752
# 10 LOINC Component       2630

rrel_is_sub2 |> count(vocabulary_id,sort=TRUE)
rrel_is_sub3 |> count(domain_id,sort=TRUE)

#because its taking for ever maybe sort by concept_name_1
#and start trying to just slice_head()
#start with a smallish one, maybe 10k & see how it does
#seems that 2.5 - 3k is max can get in this plot

rrel_is_sub3 <- rrel_is_sub2 |> 
  #try other way to just select ICD10 & snomed
  filter(vocabulary_id %in% c("ICD10","SNOMED")) |>
  filter(concept_class_id != "LOINC Class") |>
  filter(!domain_id %in% c("Drug","Type Concept","Race","Provider","Unit","Metadata","Meas Value")) |>  
  filter(!grepl("^r ",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^r ",concept_name_2, ignore.case=TRUE)) |>  
  filter(!grepl("^r'",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^r'",concept_name_2, ignore.case=TRUE)) |>
  filter(!grepl("^rf",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^rf",concept_name_2, ignore.case=TRUE)) |>  
  filter(!grepl("^rb",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^rb",concept_name_2, ignore.case=TRUE)) |>
  filter(!grepl("^radiology",concept_name_1, ignore.case=TRUE)) |>
  filter(!grepl("^radiology",concept_name_2, ignore.case=TRUE)) |>  
  arrange(concept_name_1) |> 
  slice_head(n= 2000)

#add on nice injuries
rrel_is_sub3 <- bind_rows(rrel_is_sub3,rrelicd10)

# FINAL PLOT FOR OHDSI GLOBAL POSTER
omop_graph(rrel_is_sub3, plot=FALSE, filenameroot = "rrelations",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "OMOP ART #1 : R relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

# try some cancer plots
cancer_rel <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("cancer",concept_name_1, ignore.case=TRUE)) |> 
  collect()

#26k rows in relation table with cancer in concept1

freq_cancer_rel_domain <- cancer_rel |> count(domain_id, sort=TRUE)
freq_cancer_rel_vocab <- cancer_rel |> count(vocabulary_id, sort=TRUE)

#    vocabulary_id          n
#  1 LOINC              13724
#  2 SNOMED              5883
#  3 HemOnc              3394
#  4 RxNorm Extension    1703
#  5 UK Biobank           799
#  6 Cancer Modifier      394
#  7 HCPCS                359
#  8 Read                 185
#  9 OncoTree             101
# 10 OMOP Genomic          68

cancer_rel_hemonc <- cancer_rel |> filter(vocabulary_id=="HemOnc")

omop_graph(cancer_rel_hemonc, plot=FALSE, filenameroot = "cancer_hemonc",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cancer relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#what happens if just subset HemOnc

hemonc_rel <- omop_concept_relationship() |> 
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(vocabulary_id=="HemOnc") |> 
  collect()

#70k rows

freq_hemonc_rel_domain <- hemonc_rel |> count(domain_id, sort=TRUE)
freq_hemonc_rel_rship <- hemonc_rel |> count(relationship_id, sort=TRUE)

#  1 Accepted use of       5092
#  2 Has accepted use      5092
#  3 Subsumes              4373
#  4 Brand name of         4207
#  5 Has brand name        4207
#  6 Cytotoxic chemo of    3891
#  7 Has cytotoxic chemo   3891
#  8 Has cytotox chemo Rx  3876
#  9 Is a                  3222
# 10 Context of            2872

hemonc_rel_chemo <- hemonc_rel |> filter(relationship_id=="Cytotoxic chemo of")
#3.8k rows

omop_graph(hemonc_rel_chemo, plot=FALSE, filenameroot = "chemo_hemonc",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cytotoxic chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

#I expected the above to have links from cancers to treatments - but it didn't

hemonc_rel_has_chemo <- hemonc_rel |> filter(relationship_id=="Has cytotoxic chemo")
#3.8k rows

omop_graph(hemonc_rel_has_chemo, plot=FALSE, filenameroot = "chemo_has_hemonc",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cytotoxic chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


hemonc_rel_accepted_chemo <- hemonc_rel |> filter(relationship_id=="Accepted use of")
#3.8k rows

omop_graph(hemonc_rel_accepted_chemo, plot=FALSE, filenameroot = "chemo_hemonc_accepted",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Cytotoxic chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

# try filtering lung cancer

hemonc_rel_lung <- hemonc_rel |> 
  filter(grepl("lung",concept_name_1, ignore.case=TRUE)) 

# only has conditions

omop_graph(hemonc_rel_lung, plot=FALSE, filenameroot = "chemo_hemonc_lung",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Lung chemo relations from HemOnc",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


cancer_lung_rel <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("cancer",concept_name_1, ignore.case=TRUE)) |> 
  filter(grepl("lung",concept_name_1, ignore.case=TRUE)) |> 
  collect()

# only has conditions

omop_graph(cancer_lung_rel, plot=FALSE, filenameroot = "cancer_lung",width=36, height=48, units="in", node_txtsize = 14, graphtitle = "Lung cancer relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


# pregnancy

preg_rel <- omop_concept_relationship() |>
  omop_join_name_all(domain = TRUE,vocabulary=TRUE,concept_class=TRUE) |> 
  filter(grepl("pregnan",concept_name_1, ignore.case=TRUE)) |> 
  #filter(grepl("lung",concept_name_1, ignore.case=TRUE)) |> 
  collect()

#30k pregnancy relationships

freq_preg_rel_domain <- preg_rel |> count(domain_id, sort=TRUE)
freq_preg_rel_rship <- preg_rel |> count(relationship_id, sort=TRUE)
#  1 Mapped from         4370
#  2 Maps to             3814
#  3 Is a                3438
#  4 Has Module          2654
#  5 Has status          2650
#  6 Subsumes            2460
#  7 Interprets of       1305
#  8 Has finding site     724
#  9 Has interprets       717
# 10 Concept was_a from   566

preg_rel_isa <- preg_rel |> filter(relationship_id=="Is a") 
#3.4k

#try filtering those that have preg in concept 1 & 2
preg_rel_preg <- preg_rel |> 
    filter(grepl("pregnan",concept_name_2, ignore.case=TRUE)) 
#15k

omop_graph(preg_rel_isa, plot=FALSE, filenameroot = "preg_isa",width=100, height=60, units="in", node_txtsize = 14, graphtitle = "Pregnancy 'Is a' relations",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )

pregnames <- omop_names("pregnan")
#4381 rows

birthdatenames <- omop_names("birth date")
#returning 10 concepts
birthnames <- omop_names("birth")
#returning 2116 concepts
cesariannames <- omop_names("cesarian")
#returning 4 concepts & are invalid_reason = D

#some docs, move these later

#1. decide which domain (generally using Observation as final)
#(note condition table doesn't allow you to modify things )

#2. search for concept_id

# For births you can use fact relationship table to link mother & child

# [] in Athena, square brackets indicate a standard survey

# when setting up a consortium project important that mapping conventions
# are agreed early on, otherwise one site may make decisions that impact 
# heavily on the way 

clb <- omop_names("certificate of live birth")
#26

cert_live_birth_rel <- omop_relations_recursive(1012231, num_recurse = 1)

omop_graph(cert_live_birth_rel, plot=FALSE, filenameroot = "cert_live_birth",width=30, height=20, units="in", node_txtsize = 18, graphtitle = "Certificate of live birth",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept  Commisions welcome! southandy@gmail.com" )


#omopmas 2023

chr <- omop_names('christmas')
rei <- omop_names('reindeer')
mis <- omop_names('mistletoe')

chr_rel <- omop_relations_multiple(chr$concept_id)
rei_rel <- omop_relations_multiple(rei$concept_id)
mis_rel <- omop_relations_multiple(mis$concept_id)

omop_graph(chr_rel)
omop_graph(rei_rel)

chr_rei_rel <- bind_rows(chr_rel,rei_rel)

#A4 title text over-runs
omop_graph(chr_rel, filenameroot = "omopmas", graphtitle = "Happy OMOPmas !",graphsubtitle = "made by @southmapr using OMOP, R & https://github.com/andysouth/omopcept",width=210, height=297, units="mm", node_txtsize = 24)
#A3
omop_graph(chr_rel, filenameroot = "omopmas", graphtitle = "Happy OMOPmas !",graphsubtitle = "made by @southmapr 2023 using OMOP, R & https://github.com/andysouth/omopcept",width=297, height=420, units="mm", node_txtsize = 24)


```


#### OLD below here, some useful code generating inputs 

```{r extract data, include=FALSE, eval=TRUE}

dfsnomed <- omop_descendants(v_ids="SNOMED",separation=1)
#returning 910497 concepts
dfsnomed |>  count(domain_id,sort=TRUE)
#  1 Device              382492
#  2 Condition           218064
#  3 Observation         125732
#  4 Procedure           100106
#  5 Spec Anatomic Site   54239
#  6 Measurement          24028
#  7 Specimen              3061
#  8 Meas Value            1403
#  9 Language               888
# 10 Relationship           282
# 11 Route                  192
# 12 Meas Value Operator      5
# 13 Spec Disease Status      5

#7.2 million concepts
dfsnomedall <- omop_descendants(v_ids="SNOMED")
#1 million concepts
dfloinc <- omop_descendants(v_ids="LOINC")

dfcancermod <- omop_descendants(v_ids="Cancer Modifier",separation=1)
#returning 6759 concepts
dfcancermod |>  count(domain_id,sort=TRUE)
#just one domain
#1 Measurement  6759

#to get a smaller test dataset
dffigo <- dfcancermod |> filter(str_detect(concept_name,"FIGO"))

names_lymph <- omop_names("lymphoma",v="SNOMED")

#returning 17 concepts
names_dlbcl <- omop_names("Diffuse large B-cell lymphoma",v="SNOMED")
#Diffuse large B-cell lymphoma : 44808122
dfme <- omop_descendants(c_id=44808122, v_ids="SNOMED")
#!! wow 7 million concepts descending from DLBCL returning 7277526 concepts
freq_domain_id <- dfme |>  count(domain_id,sort=TRUE)
#  1 Condition           2424403
#  2 Spec Anatomic Site  1372365
#  3 Device              1233671
#  4 Procedure           1118391
#  5 Observation          941751
#  6 Measurement          164036
#  7 Specimen              13910
#  8 Meas Value             3725
#  9 Language               3321
# 10 Relationship           1369
# 11 Route                   555
# 12 Meas Value Operator      15
# 13 Spec Disease Status      14

# they are all standard
# freq_standard_concept <- dfme |>  count(standard_concept,sort=TRUE)

freqsep <- dfme |>  count(min_levels_of_separation,sort=FALSE)
#I could limit level of separation
#still 5.6 million !
dfme5 <- omop_descendants(c_id=44808122, v_ids="SNOMED",separation=c(1:5))
#4.6 million
dfme4 <- dfme5 |> filter(min_levels_of_separation<=4) 
#3.3 million
dfme3 <- dfme5 |> filter(min_levels_of_separation<=3)
#2 million
dfme2 <- dfme5 |> filter(min_levels_of_separation<=2)
#0.9 million
dfme1 <- dfme5 |> filter(min_levels_of_separation<=1)

freq_domain_id <- dfme5 |>  count(domain_id,sort=TRUE)

#filter all snomed for just those that contain blood
#but note that dfsnomed was just separation=1
dfsnoblood <- dfsnomed |>  filter(grepl("blood", concept_name, ignore.case=TRUE)) 
#dfsnomedall has all separations
dfsnobloodgroup <- dfsnomedall |>  
  #filter(min_levels_of_separation<=3) |> 
  filter(grepl("blood group", concept_name, ignore.case=TRUE)) 

#96k
dfloincblood <- dfloinc |>  filter(grepl("blood", concept_name, ignore.case=TRUE)) 

#300
dfloincbloodgroup <- dfloinc |>  
  #filter(min_levels_of_separation<=3) |> 
  filter(grepl("blood group", concept_name, ignore.case=TRUE)) 

#news2 scores
#can get the snomed codes from omopcept, 10 rows, one seems to be ancestor
dfnews2 <- omop_names("news2", v_ids="SNOMED", d_ids="measurement" )
#WHY does this return 7 million concepts, suggests a BUG
#is this just all decsendants with a separation of 1 ??
dfnews2ds1 <- omop_descendants(37208354, separation=1)
dfnews2ds2 <- omop_descendants(37208354, separation=c(1,2))



#for oxford meeting

#139 concepts
dfoxford <-  omop_names("oxford") 

#try single descendants of oxford
#could do via concept relationship

#could go through all 139 concepts in a loop
#TODO generalise this into a function
#omop_ancestors_multi()
#or maybe even put it into omop_ancestors
dfoxdes <- dfoxanc <- NULL
for(i in 1:nrow(dfoxford))
{
  dfdtmp <- omop_descendants(dfoxford$concept_id[i]) #, separation=1) 
  dfatmp <- omop_ancestors(dfoxford$concept_id[i]) #, separation=1) 
    
  #if(i==1) dfoxdes <- dftmp
  dfoxdes <- bind_rows(dfoxdes, dfdtmp)
  dfoxanc <- bind_rows(dfoxanc, dfatmp)
}

dfox <- bind_rows(dfoxanc, dfoxdes)

dfox2 <- dfox |> filter(min_levels_of_separation <= 2)
dfox1 <- dfox |> filter(min_levels_of_separation <= 1)

#98
dfoxa1 <- dfoxanc |> filter(min_levels_of_separation <= 1)


#for NHS-R talk
vehicle_accident_descendants <- omop_descendants(4168046)

#for Steve
critical1 <- omop_concept_relationship() |> omop_join_name_all(domain=TRUE,vocabulary=TRUE) |> filter(grepl("ritical care",concept_name_1)) |>  collect()

#holidays for away day
holidays <- omop_names("holiday")
holsanc <- NULL
holsrel <- NULL
for(i in 1:nrow(holidays))
{
  #dfdtmp <- omop_descendants(dfoxford$concept_id[i]) #, separation=1) 
  #dfatmp <- omop_ancestors(holidays$concept_id[i],itself=TRUE)
  dfatmp <- omop_relations(holidays$concept_id[i])
    
  #if(i==1) dfoxdes <- dftmp
  #dfoxdes <- bind_rows(dfoxdes, dfdtmp)
  #holsanc <- bind_rows(holsanc, dfatmp)
  holsrel <-  bind_rows(holsrel, dfatmp)
}

# cancer staging

#1 concept
ajccfinding <- omop_names("AJCC/UICC finding", fixed=TRUE)

ajcc_rel1 <- omop_relations_recursive(734320, num_recurse=1)
ajcc_rel2 <- omop_relations_recursive(734320, num_recurse=2)
#does it make it quicker if I filter by vocab ? not hugely it seems
ajcc_rel2quick <- omop_relations_recursive(734320, num_recurse=2, v_ids = "Cancer Modifier")

#good first tree plot (although lots of nodes don't get labelled)
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE)
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width=200)

#dendrogram & treemap give :
#! `graph` doesn't contain a root.ℹ  Provide graph with one parentless node
# adding one row to the data can fix (see below)
# could even do it in omop_graph()
# but dendrogram & treemap initial results were a bit rubbish anyway 

ar2 <- ajcc_rel2
ar2[1+nrow(ar2),]$concept_name_2 <- ar2[1,]$concept_name_1
omop_graph(ar2, ggrlayout="dendrogram", legendshow = FALSE) #looks same as tree

#try taking out the edition nodes
ajcc_rel2_no_ed <- ajcc_rel2 |> 
  filter(!str_detect(concept_name_1, "edition"))

omop_graph(ajcc_rel2_no_ed, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 100)

# GOOD nodetxtangle = 45 makes most labels visible
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 150, nodetxtangle = 45)

omop_graph(ajcc_rel2, legendshow = FALSE, saveplot = TRUE, width = 100, height=100)

# trying a smaller plot for the vignette 2024-06

ajcc8 <- omop_names("AJCC/UICC 8th edition", exact=TRUE)

ajcc_rel1 <- omop_relations_recursive(ajcc8$concept_id, num_recurse=1)

# getting recursive relations takes a few minutes
ajcc_rel2 <- omop_relations_recursive(ajcc8$concept_id, num_recurse=2)

# plot is too big to display nicely in this vignette
# but is auto saved in a nice to pdf
omop_graph(ajcc_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 150, nodetxtangle = 45)


# figo
# interesting that figo hierarchy seems different, i.e. edition is child of stages

figofind <- omop_names("figo finding")

figofind[1,]$concept_id 

figo_rel1 <- omop_relations_recursive(734316, num_recurse=1)
figo_rel2 <- omop_relations_recursive(734316, num_recurse=2)

omop_graph(figo_rel2, ggrlayout="tree", legendshow = FALSE, saveplot = TRUE, width = 50, nodetxtangle = 45)

# try to make a pretty cancer plot for Steve's talk
# perhaps start at something detailed and work up ?
cm <- omop_names("", v_ids="Cancer Modifier")
#returning 6043 concepts
cm |> count(concept_class_id, sort=TRUE)
#  1 Staging/Grading     3281
#  2 Metastasis           579
#  3 Extension/Invasion   545
#  4 Topography           518
#  5 Histopattern         444
#  6 Margin               433
#  7 Nodes                192
#  8 Dimension             29
#  9 Morph Abnormality     15
# 10 Qualifier Value        7

bc <- omop_names("breast cancer") #244
bcs <- omop_names("breast cancer",v="SNOMED") #49

labc <- omop_names("Locally advanced breast cancer")
labcr1 <- omop_relations_recursive(labc$concept_id[1],num_recurse = 1)


mm <- omop_names("multiple myeloma")
#returning 53 concepts
mms <- omop_names("multiple myeloma",exact=TRUE,d="Condition",v="SNOMED",s="S")
#1
mmsr1 <- omop_relations(mms$concept_id)
#returning 50 concepts
mmsr1 |> count(relationship_id, sort=TRUE)
#  1 Mapped from             18
#  2 Subsumes                11
#  3 Due to of                7
#  4 Concept same_as from     3
#  5 Asso finding of          2
#  6 Focus of                 2
#  7 Asso with finding        1
#  8 Concept replaces         1
#  9 Has Module               1
# 10 Has asso morph           1
# 11 Has status               1
# 12 Is a                     1
# 13 Value mapped from        1
#This is nice, MMyeloma at centre, 6 different domains
omop_graph(mmsr1)


#with newly added names2avoid defaults that avoid e.g. Primitive
mmsr2 <- omop_relations_recursive(mms$concept_id, num_recurse=2)

omop_graph(mmsr2)

#2024-06-02 ohdsi concepts workshop
#Snomed does not think that Arthropathic psoriasis is a psoriasis !
#ICD10 does

#get one parent concept
pso <- omop_names("Psoriasis",exact=TRUE,s="S",v="SNOMED")
psorel2

ra <- omop_names("rheumatoid arthritis",exact=TRUE,s="S",v="SNOMED")

ra_rel1 <- omop_relations_recursive(ra$concept_id, num_recurse=1)
ra_rel2 <- omop_relations_recursive(ra$concept_id, num_recurse=2)

ra_rel1mapped <- ra_rel1 %>% filter(relationship_id=="Mapped from")
ra_rel2mapped <- ra_rel2 %>% filter(relationship_id=="Mapped from")

#look at hierarchy of ICD10 codes for RA

m06 <- omop_codes("M06.0")
m06_rel <- omop_relations_recursive(m06$concept_id)
omop_graph(m06_rel)
m06_rel2 <- omop_relations_recursive(m06$concept_id, num_recurse = 2)

omop_graph(m06_rel2, ggrlayout = "tree")

#to do regex &, need to search both one after other & other way around
amox_clav <- omop_names("amoxicillin.*clavulanate|clavulanate.*amoxicillin")

amox_clav <- omop_names("amoxicillin.*clavulanate|clavulanate.*amoxicillin",v=c("RxNorm","RxNorm Extension"))

amox_clav %>% count(concept_class_id, sort=TRUE)

multing <- amox_clav %>% filter(concept_class_id=="Multiple Ingredients")

# 2024-07-03
# looking at relationship_ids with John
# every relationship_id has an equivalent going in other direction
# and they have identical num rows, 
# so sorting on the count puts them next to each other
freq_r <- omop_concept_relationship() |> count(relationship_id, sort=TRUE) |>  collect()


# 2024-07-05
# new approach finding a generic concept & just searching down (Subsumes)
# allows a representative tree map to be produced

neor2 <- omop_relations_recursive("Malignant neoplasms",num_recurse = 2,r="Subsumes")


#this is pretty good
omop_graph(neor2, plot=FALSE, filenameroot = "neoplasm_subsumes2",width=80, height=110)

# 2024-07-15
pleasure <- omop_names("pleasure")
returning 36 concepts
pain <- omop_names("pain")
returning 9278 concepts
painstandard <- omop_names("pain",s="S")
returning 5041 concepts
#too many
painstandard |> count(domain_id,sort=TRUE)
 1 Drug          2668
 2 Condition      967
 3 Observation    929
 4 Meas Value     207
 5 Measurement    152
 6 Procedure       49
 7 Note            37
 8 Device          21

 
# BLACK & WHITE 
 
black <- omop_names("black")
#returning 19680 concepts
white <- omop_names("white")
#returning 8793 concepts

# filter out concepts with long names
#613
black30 <- black |> filter(stringr::str_length(concept_name) <= 30)
#808
white30 <- white |> filter(stringr::str_length(concept_name) <= 30)

#285
black20 <- black |> filter(stringr::str_length(concept_name) <= 20)
#330
white20 <- white |> filter(stringr::str_length(concept_name) <= 20)
 	
#relations1 of all concepts
#black20r1test <- black20$concept_id[1:3] |> omop_relations_multiple()

black20r1 <- black20$concept_id |> omop_relations_multiple() #1526
white20r1 <- white20$concept_id |> omop_relations_multiple() #2821

#removing some boring concepts, e.g. pharma companies
black20r1a <- black20r1 |> filter(!str_detect(concept_name_2,"Blackmores") & !str_detect(concept_name_1,"Blackmores")) #1421 

white20r1a <- white20r1 |> filter(!str_detect(concept_name_2,"White Chemists") & !str_detect(concept_name_1,"White Chemists")) #1804  

filter_rship_concept_namelengths <- function(df, namelength=100)
{
  df |> filter(stringr::str_length(concept_name_1) <= namelength &
               stringr::str_length(concept_name_2) <= namelength)
}

black20r1b <- black20r1a |> 
  filter_rship_concept_namelengths(120) |>  #1305
  mutate(bw="black")
white20r1b <- white20r1a |> 
  filter_rship_concept_namelengths(120) |>  #1748
  mutate(bw="white")

bwb <- bind_rows(black20r1b,white20r1b) #3053

write_csv(black20r1,file=here("..","omopcept-plots","data","black20r1.csv"))
write_csv(white20r1,file=here("..","omopcept-plots","data","white20r1.csv"))

omop_graph(white20r1a, filenameroot="white20r1a", width=150, height=150)
omop_graph(black20r1, filenameroot="black20r1", width=150, height=150)

omop_graph(bwb, filenameroot="bwb", width=150, height=150)
omop_graph(bwb, filenameroot="bwb", width=150, height=150,textcolourvar ="bw",nodecolourvar="bw")

# omop_graph, have text (& symbols ?) in black & white
# try a grey background so both texts can show up
#theme(panel.background=element_rect(fill="lightgray", colour="lightgray", size=0.5)


# TODO bigger snomed accident hierarchy
# + can I pair accidents with something about treatment
# maybe similarly
# accidents: recursive relations of a single concept
# treatment: snomed procedure
# Emergency procedure [25 children]
# Procedure on wound [105 children]
# bandages, plaster, stitches ...
# title demand v supply :-)

#note there are SNOMED concepts that start [X] maybe they need to be filtered out
#I should offer option to filter & maybe doso by default
#That’s a historical artefact. In the Read vocabulary, [X] meant concept derived from ICD-10. When SNOMED-RT and Read were merged, these were all poured into the new SNOMED-CT, and then later sequestered into the SNOMED UK-Version (which we implemented because of the Read codes in CPRD and THIN). SNOMED is phasing them out. Sooner or later they will be gone entirely.
# Same is true for [V] and [Q] (observations and qualifiers from ICD-9), [SO] (anatomical sites from OPCS) and [M] (morphology terms from ICD-O).
# Don’t use them, just ignore them.
#https://forums.ohdsi.org/t/what-does-x-mean-in-concept-name/4531/4

sharp <- omop_names("Accident caused by sharp-edged object", standard="S")
acc <- omop_names("Accident", exact=TRUE, standard="S", v_ids="SNOMED")

sharpr2 <- omop_relations_recursive(sharp$concept_id, 
                                      r_ids=c('Is a','Subsumes'), 
                                      num_recurse=2) 
sharpr_upr5 <- omop_relations_recursive(sharp$concept_id, 
                                      r_ids=c('Is a'), 
                                      num_recurse=5) 
#this takes many hours 
#(note would be interesting to see if just filtering relationship table 
# for str_detect("accident") has similar result & would be much quicker
# could also check on this which rows wouldn't be caught by that)
#4059 rows
acc_downr7r <- omop_relations_recursive(acc$concept_id, 
                                      r_ids=c('Subsumes'), 
                                      num_recurse=7) 
write_csv(acc_downr7r,file=here("..","omopcept-plots","data","acc_downr7r.csv"))

filter_rship_names <- function(df, stringremove)
{
  df |> filter(!stringr::str_detect(concept_name_1,stringremove) &
               !stringr::str_detect(concept_name_2,stringremove) )
}

#3158
acc_downr7rb <- acc_downr7r |> filter_rship_names("[X]")

#A0 84x119cm
omop_graph(acc_downr7, filenameroot="acc_downr7", width=84, height=119)

omop_graph(acc_downr7b, filenameroot="acc_downr7b", width=150, height=150) #,textcolourvar ="bw",nodecolourvar="bw")

## Getting there !!!
omop_graph(acc_downr7rb, filenameroot="acc_downr7rb_recurse",
           width=170, height=170, 
           textcolourvar ="recurse_level",
           nodecolourvar="recurse_level",
           palettebrewer = "YlOrRd",
           legendshow = FALSE,
           graphtitle = "Be careful !",
           titletxtsize = 200,
           titlecolour = "darkred")

## Oooo this is nice with a black background
omop_graph(acc_downr7rb, filenameroot="acc_downr7rb_recurse",
           width=170, height=170, 
           textcolourvar ="recurse_level",
           nodecolourvar="recurse_level",
           palettebrewer = "YlOrRd",
           legendshow = FALSE,
           graphtitle = "Be careful !",
           titletxtsize = 200,
           backcolour="black",
           titlecolour = "darkred",
           edgecolour="yellow",
           nodetxtsize=11)
#reversing palettedirection, increase nodetextsize
omop_graph(acc_downr7rb, filenameroot="acc_downr7rb_recurse",
           width=170, height=170, 
           textcolourvar ="recurse_level",
           nodecolourvar="recurse_level",
           palettebrewer = "YlOrRd",
           palettedirection = -1,
           legendshow = FALSE,
           graphtitle = "Be careful !",
           titletxtsize = 200,
           backcolour="black",
           titlecolour = "darkred",
           edgecolour="yellow",
           nodetxtsize=12)


############################################################
#####***GOOD ONE*** edge red & reversed YlOrRed recurselevel
#edgecolour red
caption <- "Shown here are the standard names, used by the NHS, for all accidents. They are all concepts with a numeric code defined in a terminology called SNOMED CT. Using standards like this makes patient care and research much more efficient. UCLH stores data like this and translates it to something called the OMOP Common Data Model to enable comparison between hospitals. Plot made by Andy South using R, ggplot2 & omopcept."

omop_graph(acc_downr7rb, filenameroot="acc_downr7rb_recurse_caption",
           width=180, height=180, 
           textcolourvar ="recurse_level",
           nodecolourvar="recurse_level",
           palettebrewer = "YlOrRd",
           palettedirection = -1,
           legendshow = FALSE,
           graphtitle = "Be careful !",
           titletxtsize = 200,
           backcolour="black",
           titlecolour = "darkred",
           edgecolour="red",
           nodetxtsize=12,
           caption=caption,
           captiontxtsize=24)

##end of good one

#TODO for the accident one I could use string search to classify & then colour by
# car, bus, train, motorbike, bicycle, aircraft, boat, other

acc_downr7c <- acc_downr7b |> 
  mutate(
    # Replace some, but not all, of the species
    accident_type = case_when(
      str_detect(concept_name_2,"aircraft") ~ "aircraft",
      str_detect(concept_name_2,"boat") ~ "boat",      
      str_detect(concept_name_2,"motor vehicle") ~ "car",
      str_detect(concept_name_2,"bus") ~ "bus",
      str_detect(concept_name_2,"train") ~ "train",
      str_detect(concept_name_2,"cycle") ~ "cycle",
      str_detect(concept_name_2,"burn") ~ "burn",      
      .default = "other"
    ))

omop_graph(acc_downr7c, filenameroot="acc_downr7c",
           textcolourvar="accident_type", 
           nodecolourvar="accident_type",
           nodetxtnudgey = 0.7,
           width=150, height=150)

procwound <- omop_names("Procedure on wound", exact=TRUE, standard="S", v_ids="SNOMED")

procemerg <- omop_names("Emergency procedure", exact=TRUE, standard="S", v_ids="SNOMED")

#373 (only) rows
procwound_downr7 <- omop_relations_recursive(procwound$concept_id, 
                                      r_ids=c('Subsumes'), 
                                      num_recurse=7) 
write_csv(procwound_downr7,file=here("..","omopcept-plots","data","procwound_downr7.csv"))


procemerg_downr7b <- omop_relations_recursive(procemerg$concept_id,
                                      r_ids=c('Subsumes'), 
                                      num_recurse=7)

write_csv(procemerg_downr7b,file=here("..","omopcept-plots","data","procemerg_downr7b.csv"))

omop_graph(procwound_downr7, filenameroot="procwound_downr7", width=84, height=119)

#trying to colour by recurse level
omop_graph(procemerg_downr7b, filenameroot="procemerg_downr7b",
           textcolourvar="recurse_level", 
           nodecolourvar="recurse_level",
           nodetxtnudgey = 0.7,
           width=84, height=119)

procs_downr7 <- bind_rows(procemerg_downr7, procwound_downr7)

omop_graph(procs_downr7, filenameroot="procs_downr7", width=84, height=119)

accprocs_downr7 <- bind_rows(acc_downr7b, procs_downr7)

omop_graph(accprocs_downr7, filenameroot="accprocs_downr7",
           #textcolourvar="accident_type", 
           #nodecolourvar="accident_type",
           #nodetxtnudgey = 0.7,
           width=170, height=170)

# ANESTHESIA

#1
anes <- omop_names("Administration of anesthesia",exact=TRUE,v="SNOMED")

anes_downr7 <- omop_relations_recursive(anes$concept_id,
                                      r_ids=c('Subsumes'), 
                                      num_recurse=7)

write_csv(anes_downr7,file=here("..","omopcept-plots","data","anes_downr7.csv"))

############################################################
#####***GOOD ONE***
caption <- "Standardised names for anesthesia procedures used in the NHS (concepts with a numeric code defined in SNOMED CT). Standards make patient care and research more efficient. \nUCLH stores data in SNOMED and translates it to another standard (the OMOP Common Data Model) to enable comparison between hospitals. Plot made by Andy South using R, ggplot2 & omopcept."

#hack to try to avoid lightest colours
#add a few rows with lower values
anes_downr7b <- bind_rows(anes_downr7,data.frame(recurse_level=c(-1,0),concept_name_1="egg",concept_name_2="egg")) |> 
  mutate(recurse_level = recurse_level+2)
#anes_downr7b |> count(recurse_level)

omop_graph(anes_downr7b, filenameroot="anes_downr7rb",
           width=84, height=119, 
           textcolourvar ="recurse_level",
           nodecolourvar="recurse_level",
           palettebrewer = "Greens",
           palettedirection = 1,
           legendshow = FALSE,
           graphtitle = "Rock-a-bye-Baby",
           titletxtsize = 130,
           backcolour="white",
           titlecolour = "darkred",
           edgecolour="burlywood",
           nodetxtsize=18,
           caption=caption,
           captionjust="centre",
           captiontxtsize=18)


# BIRTH v DEATH
#
#Pregnancy, childbirth and puerperium finding [19 children]
#Death [37 children]


# cancer treatment

ctr1 <- omop_relations_recursive("Cancer treatment", num_recurse = 1)
ctr2 <- omop_relations_recursive("Cancer treatment", num_recurse = 2)
#returning 13 concepts
#but then doing 3 got massive

#mooning
glut <- omop_names("gluteus")
#returning 47 concepts
glutr1 <- omop_relations_multiple(glut$concept_id)
#248
omop_graph(glutr1)

#looking for all antibiotics in dm+d for Tim & Alan

#there is 'antibiotic' in snomed, but hierarchy poor prob because non-standard
antibds <- omop_names("antibiotic",exact=TRUE,d="Drug",v="SNOMED")
#1
#7 concepts not much use
antibds_r1 <- omop_relations_recursive(antibds$concept_id)

#try dm+d direct
antibdmd <- omop_names("antibiotic",v="dm+d")
#24 concepts, nothing very useful

#maybe see if can get generic from RXNorm Extension
antibrxe <- omop_names("antibiotic",v="RXNorm extension")
#179

#amoxi in dm+d has single relation that is in RxNorm
amovtm <- omop_names("Amoxicillin",cc="VTM")
amovtm_r1 <- omop_relations_recursive(amovtm$concept_id)
#amoxi in RxNorm has 1034 relations
amovtm_r2 <- omop_relations_recursive(amovtm$concept_id,num_recurse = 2)
amovtm_r2 |> count(relationship_id,sort=TRUE)

#    relationship_id          n
#  1 Has brand name         609
#  2 RxNorm ing of          206
#  3 Mapped from            136
#  4 RxNorm - ATC sec up     44
#  5 RxNorm - ATC sec lat    12
#  6 RxNorm - ATC pr up       7
#  7 RxNorm - Source eq       4
#  8 Has form                 3
#  9 Rx antineopl of          3
# 10 Rx support med of        3
# 11 Is a                     2
# 12 RxNorm - ATC pr lat      2
# 13 RxNorm - SNOMED eq       2
# 14 Source - RxNorm eq       1
# 15 Value mapped from        1

amo_rx_isa <- amovtm_r2 |> filter(relationship_id=="Is a")
amo_rx_isa |> select(concept_name_2,concept_class_id,domain_id,vocabulary_id)

#   concept_name_2                        concept_class_id domain_id vocabulary_id
# 1 WHO Essential Anti-infective Medicine Component Class  Drug      HemOnc       
# 2 Penicillin                            Component Class  Drug      HemOnc   

#2024-09-04 leaving gift for Tim
tim <- omop_names("tim")

timstrt <- omop_names("tim",exact="start")
#returning 3229 concepts
tim_strt <- omop_names("tim ",exact="start")
#returning 0 concepts
timothy <- omop_names("timothy")
#returning 800 concepts
timothystrt <- omop_names("timothy",exact="start")
#returning 398 concepts

#ooo this is cool how can pipe & pull
timsynr1 <- omop_names("Timothy syndrome",exact=TRUE) |> pull(concept_id) |> omop_relations_recursive()

#Aha thinking about it
#what I could do is just filter the relations table
#for rows where concept1 &/or concept2 contain a string
#and maybe I should develop a function to do that
#phaps called omop_relations_names()
#can use omop_concept_relationship() that exists already

#have started the function, but just trying without the func here
#
timr1 <- omop_concept_relationship() |>
    #join name for ID1 & other concept columns
    left_join(omop_concept(),
    #left_join( select(omop_concept(),concept_id,concept_name),
               by=c("concept_id_1"="concept_id")) |>
    rename(concept_name_1=concept_name) |>
    #join name for ID2
    left_join( select(omop_concept(),concept_id,concept_name),
               by=c("concept_id_2"="concept_id")) |>
    rename(concept_name_2=concept_name) |>  
    filter(str_detect(concept_name_1,"^Tim")) |> 
    collect()

freqr <- timr1 |> count(relationship_id, sort=TRUE)

freqr |> filter(relationship_id %in% c("Is a","Subsumes"))
#1 Is a              669
#2 Subsumes          488

timr1is <- timr1 |> filter(relationship_id %in% c("Is a"))
timr1subs <- timr1 |> filter(relationship_id %in% c("Subsumes"))

freqrd <- timr1is |> count(domain_id, sort=TRUE)

timr1is2 <- timr1is |> filter(domain_id %in% c("Observation","Measurement","Drug","Condition","Procedure","Device"))
timr1subs2 <- timr1subs |> filter(domain_id %in% c("Observation","Measurement","Drug","Condition","Procedure","Device"))

caption <- "Tim, thank you for being a great boss and your inspiring work on OMOP at UCLH. We will miss you.\nPlot shows OMOP concepts starting with 'Tim' and their immediate parents."

omop_graph(timr1is2, filenameroot="timr1is",
           width=70, height=70,
           graphtitle="Tim in OMOP",
           caption=caption,
           captionjust="centre",
           captiontxtsize=18)
#A2
omop_graph(timr1is2, filenameroot="timr1is",
           width=42, height=59.4,
           graphtitle="Tim in OMOP",
           caption=caption,
           captionjust="centre",
           captiontxtsize=18)

#A2 subs
caption <- "Tim, thank you for being a great boss and your inspiring work on OMOP at UCLH. We will miss you.\nPlot shows OMOP concepts starting with 'Tim' and their immediate children."
omop_graph(timr1subs2, filenameroot="timr1subs",
           width=42, height=59.4,
           palettebrewer = "Dark2", palettedirection = 1, #1=default,-1=reverse
           graphtitle="Tim in OMOP", titletxtsize = 30,
           caption=caption,
           captionjust="centre",
           captiontxtsize=18)

#2024-09-15 plots for OHDSI UK lighning talk
#try producing pngs at a resolution that can be inserted directly to slides
#web search says 1920x1080 pixels is optimal

#this example is good for testing
#r_ids=c('Subsumes'), #gets just 7 concepts
#r_ids=c('Is a','Subsumes') #more concepts
#r_ids=c('Subsumes','Maps to'),#trying to get itself
sharp <- omop_names("Accident caused by sharp-edged object", standard="S")
relations <- omop_relations_recursive(sharp$concept_id, 
                                      r_ids=c('Subsumes'), 
                                      #itself=TRUE,
                                      num_recurse=2) 
itself <- data.frame(concept_name_1="Accident caused by sharp-edged object",
                     concept_name_2="Accident caused by sharp-edged object",
                     relationship_id="Is",
                     domain_id="Observation",
                     recurse_level=0)
r2 <- bind_rows(relations, itself)

#aha! maybe problem is that from & to are the wrong way around for colours
#HURRAH! that worked
r3 <- r2 |> 
  rename(concept_name_1=concept_name_2,
         concept_name_2=concept_name_1)

#textcolourvar="recurse_level" reveals issues with colouring
#tin can should be recurse1, but gets 2
#also may need to add realtion to itself to get it to work
omop_graph(r3,
           graphtitle=NULL, legendshow=FALSE, 
           width=1920, height=1080, units="px",
           nodetxtsize=2, #default=9
           edgewidth=0.5,#default=0.1
           textcolourvar="recurse_level",
           filenamecustom="ohdsi-uk-24-snomed-sharp-injuries.png",
           filetype="png"
           )


```

```{r first test plot, include=FALSE, eval=TRUE}

# If you want to go beyond ~20k nodes, then you may want to switch to layout_with_pmds() or layout_with_sparse_stress() which are optimized to work with large graphs.


#selecting data to plot
#challenge to get down to a small enough number
dfin <- dffigo
dfin <- dfme3
dfin <- dfme3 |> head(2000)

dfin <- dfme1

#MAYBE SAVE ONE OF OMOP DATA OBJECTS IN PACKAGE TO SPEED PLOT PRODUCTION

#try filtering an equal number of domains
dfin <- dfme3 |> 
#post submission perhaps I want to start from just direct connections, separation1
#but the plot didn't look as good! not sure which is best
#dfin <- dfme1 |>   
  filter(domain_id %in% freq_domain_id$domain_id[1:7]) |> 
  group_by(domain_id) |> 
  #top x rows for each group
  slice_head(n=500) |> 
  ungroup()


# dfin <- dfsnoblood
# dfin <- dfsnobloodgroup
# dfin <- dfloincblood
# dfin <- dfloincbloodgroup

dfin <- dfnews2d
dfin <- dfoxa1
dfin <- vehicle_accident_descendants
dfin <- critical1
dfin <- holsanc
dfin <- holsrel


if ("ancestor_name" %in% names(dfin)){
  
  #DESCENDANT
  dfin2 <- dfin |> 
    dplyr::rename(from = ancestor_name,
                  to = concept_name)    
  
} else if ("descendant_concept_name" %in% names(dfin)){
  
  #ANCESTOR
  dfin2 <- dfin |>
   dplyr::rename(from = descendant_concept_name,
                 to = concept_name)
  
} else if ("concept_name_1" %in% names(dfin)){
  
  #RELATION
  dfin2 <- dfin |>
   dplyr::rename(from = concept_name_1,
                 to = concept_name_2)
  
}

  
#saving plots
#naming convention
#s  separation min
#m  plot metres
#ea edge alpha
#ta text alpha  
#pdark2 palette color brewer
#ns node sized
#nts node text size
#d? domains
  

```

